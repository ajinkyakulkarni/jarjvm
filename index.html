<!DOCTYPE html>
<html lang="en">
	<head>
		<script type="text/javascript" src="Util.js"></script>
		<script type="text/javascript" src="Stack.js"></script>
		<script type="text/javascript" src="console.js"></script>
		<LINK href="indexStyle.css" rel="stylesheet" type="text/css" />
		
		<title>JAR JVM</title>
	</head>
	<body onload="consoleInit()">
		<div id="main">
			<div id="header">
				JAR JVM 
			</div>
			<div id="upload">
				<div id="instructions">
					<ul>
						<li>Upload the Java class files needed to run your program.  The file selection box will let you select multiple files</li>
						<li>If you need help with the console type 'help'</li>
						<li>To execute your program type 'execute className'.  ClassName must contain a main function.  '.class' should not be included.</li>
					</ul></div>
				<form><input type="file" id="files" size="50" name="files[]" multiple /></form>
			</div>
			<div id="program">
				<div id="consoleContainer">
					<div id="console" tabindex="1" onkeypress="userTyped(event)">

					</div>
				</div>
				<div id="stackContainer">
					<div id="stack" tabindex="2">
					</div>
				</div>
				<div style="clear:both">  </div>
			</div>
		<output id="list"></output>
		<br />
		<br />
		<script>
			/** Include all of our scripts **/
			//NOTE: Stack is included above because we use it for a global.
			include("Primitive.js");
			include("JavaObject.js");
			include("JavaScriptStackTrace.js");
			include("Attributes.js");
			include("ByteCode.js");
			include("Class.js");
			include("ConstantPoolInfo.js");
			include("Deflate.js");
			include("FieldInfo.js");
			include("Frame.js");
			include("MethodInfo.js");
			include("MethodRun.js");
			include("Instruction.js");
			include("Descriptor.js");
			include("NativeFunctions.js");
			include("Long.js");

		
			DEBUG = false; //USED to turn off console text except for WARNING, ERROR, and OUTPUT
		
			STACK = new Stack();
			CLASSES = new Array();
			// Program Counter
			PC = 0;
			// Current Constant Pool
			CONSTANTPOOL = undefined;
			// Set to 'true' when a context switch is about to occur.
			// Reset just before a method call.
			CONTEXTSWITCH = false;

			Exception = {
				EXCEPTION : 1,
				METHOD_CALL : 2,
				RETURNING : 3,
				CATCH_FOUND : 4
			};

			/**
			 * Used to read a Java Class.
			 */
			function JavaClassReader(data) {
				this.data = data;
				this.index = 0;

				/**
				 * Get the next length bytes of the class file as an unsigned integer array.
				 */
				this.getRawBytes = function(length) {
					//var bytes = this.data.subarray(this.index, this.index + length);
					var bytes = new Array();
					
					for (var i = this.index; i < this.index + length; i++)
					{
						bytes[i-this.index] = this.data.charCodeAt(i);
					}
					
					this.index += length;
					return bytes;
				};
				/**
				 * Get an unsigned integer field. Converts multi-byte fields into a single
				 * unsigned integer.
				 */
				this.getUintField = function(fieldLength) {
					var bytes = this.getRawBytes(fieldLength);

					var value = 0;
					for(var i = 0; i < bytes.length; i++) {
						//Shift over the previous value by a byte.
						value = value << 8;

						//Add the next byte.
						value = value | bytes[i];
					}
					//Convert back to unsigned. Yes, this is really dumb and hacky, but that's the only way.
					value = value >>> 0;
					return value;
				};
				/**
				 * Returns a float.
				 */
				this.getFloatField = function(fieldLength) {
					assert(fieldLength == 4);
					var rawBits = this.getUintField(fieldLength);
					var s = ((rawBits >> 31) == 0) ? 1 : -1;

					//Make it unsigned.
					var e = ((rawBits >> 23) & 0xff);
					e = e >>> 0;

					//Make it unsigned.
					var m = (e == 0) ? (rawBits & 0x7fffff) << 1 : (rawBits & 0x7fffff) | 0x800000;
					m = m >>> 0;

					var value = s * m * Math.pow(2, e - 150);
					return value;
				};
				/**
				 * Returns a double.
				 */
				this.getDoubleField = function(fieldLength) {
					assert(fieldLength == 8);
					
					var bits_1 = this.getUintField(2);
					
					//Sign.
					var s = ((bits_1>>15) == 0) ? 1 : -1;
					
					//Exponent. Make it unsigned.
					var e = ((bits_1>>4) & 0x7ff);
					e = e >>> 0;
					
					//3 bits of m here.
					var m = bits_1 & 0xf;
					
					if (e != 0)
						m = (bits_1 & 0xf) | 0x10;
						
					//We CANNOT use any more bit operations on the mantissa,
					//since bit ops operate on 32 bits ONLY.
					
					//"Shift" it over by 4 bytes.
					m *= Math.pow(2,32);
					//"Or" it with the next 4 bytes.
					m += this.getUintField(4);
					//"Shift" it 2 more bytes.
					m *= Math.pow(2,16);
					//"Or" it with the final 2 bytes.
					m += this.getUintField(2);
					
					//Left shift 1 if e is 0.
					if (e == 0)
						m *= 2;

					var value = s * m * Math.pow(2, e - 1075);
					return value;
				};
				/**
				 * Get a SIGNED INTEGER field.
				 */
				this.getIntField = function(fieldLength) {
					assert(fieldLength <= 4);
					var bytes = this.getRawBytes(fieldLength);

					var value = 0;
					for(var i = 0; i < bytes.length; i++) {
						//Shift over the previous value by a byte.
						value = value << 8;

						//Add the next byte.
						value = value | bytes[i];
					}
					
					//Need to sign extend if it is <4 bytes.
					if (fieldLength < 4)
					{
						//Form a mask to find the leftmost bit.
						var leftmostMask = 0x80;
						//Multiply by 0x10 for each byte.
						for (var i = 1; i < fieldLength; i++)
						{
							leftmostMask *= 0x100;
						}
						//Check if the leftmost bit is 1 or 0. Use to select the
						//pad value.
						var padValue = (value & leftmostMask) != 0 ? 0xFF : 0;
						
						//If it's 0, there's nothing to do. Terminate.
						if (padValue == 0) return value;
						
						//Otherwise, pad on.
						var padMask = 0;
						
						//Form the mask to left pad with.
						for (var i = 0; i < 4 - fieldLength; i++)
						{
							padMask <<= 8;
							padMask |= padValue;
						}
						
						//Left shift it the number of bits of the field.
						padMask <<= fieldLength * 8;
						
						//Finally, OR with the mask!
						value |= padMask;
					}

					return value;
				};
				/**
				 * Turns raw bytes in the Java Class file into a UTF8 string.
				 */
				this.getUTF8Field = function(fieldLength) {
					var bytes = this.getRawBytes(fieldLength);
					var utf8tler = new Utf8Translator(new utf8Wrapper(bytes));
					var string = "";
					var currentChar = utf8tler.readChar();
					while(currentChar != null) {
						string += currentChar;
						currentChar = utf8tler.readChar();
					}
					return string;
				};
			}

			//HACK
			SYSTEMINITIALIZED = false;

			function handleFileSelect(evt) {
				//Initialize system.
				addProgressToConsole("Loading User Classes");
				
				if (!SYSTEMINITIALIZED)
				{
					var systemClass = Class.getClass("java/lang/System");
					MethodRun.callFromNative("java/lang/System", "initializeSystemClass", "()V");
					SYSTEMINITIALIZED = true;	
				}
				addTextToConsole("System Initialized");
				var files = evt.target.files;
				// FileList object

				for(var i = 0, f; f = files[i]; i++) {

					var reader = new FileReader();

					reader.onloadend = function(evt) {
						if(evt.target.readyState == FileReader.DONE) {
							addProgressToConsole("File Read In");
							var bytes = evt.target.result;
							var javaClassReader = new JavaClassReader(bytes);
							var aClass = new Class(javaClassReader);
							assert(javaClassReader.index == javaClassReader.data.length);
							promptForUserInput();
						}
					};

					//reader.readAsArrayBuffer(f);
					reader.readAsBinaryString(f);
				}
			}


			document.getElementById('files').addEventListener('change', handleFileSelect, false);

		</script>
		</div>
	</body>
</html>
